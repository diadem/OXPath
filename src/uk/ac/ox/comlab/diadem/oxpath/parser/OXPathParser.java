/* Generated By:JJTree&JavaCC: Do not edit this line. OXPathParser.java */
package uk.ac.ox.comlab.diadem.oxpath.parser;
import uk.ac.ox.comlab.diadem.oxpath.parser.ast.*;


import java.io.FileReader;

import java.lang.StringBuilder;

import java.io.StringReader;

import java.util.ArrayList;

import uk.ac.ox.comlab.diadem.oxpath.dom.ActionKeywords;

import uk.ac.ox.comlab.diadem.oxpath.utils.OXPathException;

import uk.ac.ox.comlab.diadem.oxpath.model.language.functions.XPathFunction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.functions.XPathFunctions;

import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.BinaryOperator;
import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.HigherLevelOp;
import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.EqualityExprOp;
import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.RelationalExprOp;
import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.AdditiveExprOp;
import uk.ac.ox.comlab.diadem.oxpath.model.language.operators.MultiplicativeExprOp;

import uk.ac.ox.comlab.diadem.oxpath.model.language.AxisType;
import uk.ac.ox.comlab.diadem.oxpath.model.language.NodeTestType;
import uk.ac.ox.comlab.diadem.oxpath.model.language.Axis;
import uk.ac.ox.comlab.diadem.oxpath.model.language.ForwardAxis;
import uk.ac.ox.comlab.diadem.oxpath.model.language.BackwardAxis;
import uk.ac.ox.comlab.diadem.oxpath.model.language.OXPathAxis;
import uk.ac.ox.comlab.diadem.oxpath.model.language.AbbreviatedAxis;
import uk.ac.ox.comlab.diadem.oxpath.model.language.OXPathNodeTest;
import uk.ac.ox.comlab.diadem.oxpath.model.language.XPathNodeTest;
import uk.ac.ox.comlab.diadem.oxpath.model.language.ParameterizedProcessingInstruction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.XPathNameTest;
import uk.ac.ox.comlab.diadem.oxpath.model.language.NodeTest;
import uk.ac.ox.comlab.diadem.oxpath.model.language.OXPathExtractionMarker;
import uk.ac.ox.comlab.diadem.oxpath.model.language.Selector;
import uk.ac.ox.comlab.diadem.oxpath.model.language.SelectorPredicate;
import uk.ac.ox.comlab.diadem.oxpath.model.language.Action;
import uk.ac.ox.comlab.diadem.oxpath.model.language.PositionAction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.ExplicitAction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.KeywordAction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.VariableAction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.URLAction;
import uk.ac.ox.comlab.diadem.oxpath.model.language.ActionType;
import uk.ac.ox.comlab.diadem.oxpath.model.language.Step;
import uk.ac.ox.comlab.diadem.oxpath.model.language.OXPathStep;
import uk.ac.ox.comlab.diadem.oxpath.model.language.AbbreviatedStep;
import uk.ac.ox.comlab.diadem.oxpath.model.language.OXPathPredicate;


public class OXPathParser/*@bgen(jjtree)*/implements OXPathParserTreeConstants, OXPathParserConstants {/*@bgen(jjtree)*/
  protected JJTOXPathParserState jjtree = new JJTOXPathParserState();

public OXPathParser()
  {

  }

  public static void main(String args [])
  {
    try
    {
      FileReader reader = new FileReader(args[0]);
      OXPathParser oxpathparser = new OXPathParser(reader);
      Node n = oxpathparser.Expression();
 }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

   /**
   * Returns JJTree of script
   */
   public static Node getJJTree(String inputfile) throws OXPathException
           {
               try
               {
                 FileReader reader = new FileReader(inputfile);
                 OXPathParser oxpathparser = new OXPathParser(reader);
                 return oxpathparser.Expression();
               } catch (Exception e)
               {
                         throw new OXPathException("Parser exception!",e);
              }
           }

           public static Node getJJTreeFromString(String in) throws OXPathException
           {
           try
           {
                      return new OXPathParser(new StringReader(in)).Expression();
                    } catch (Exception e)
                    {
                      throw new OXPathException("Parser Exception!",e);
                    }
           }

           public static Node safeGetChild(Node parent, int index) throws OXPathException {
     if (isSafeChild(parent,index))
     {
       return parent.jjtGetChild(index);
     }
     else throw new OXPathException("Not an OXPath AST node!");
           }

           public static boolean isSafeChild(Node parent, int index) {
             if (parent.jjtGetChild(index) instanceof Node)
             {
               return true;
             }
             else
             {
               return false;
             }
           }

           public static boolean hasChildByName(Node parent, String name)
           {
             for (int i = 0; i<parent.jjtGetNumChildren(); i++)
             {
               if (parent.jjtGetChild(i).toString().contains(name))
               {
                 return true;
               }
     }
     return false;
           }

                public static boolean hasDescendantOrSelfByName(Node parent, String name) throws OXPathException
           {
             if (parent.toString().contains(name)) return true;
             else
             {
               for (int i = 0; i<parent.jjtGetNumChildren(); i++)
                   {
                      if (hasDescendantOrSelfByName(parent.jjtGetChild(i),name)) {
                          return true;
                      }
           }
     }
     return false;
           }

           public static boolean hasActionOnMainPath(Node node)
           {
                        if (node.toString().contains("ASTOXPathActionPath")) return true;
                        else
                        {
                                for (int i = 0; i < node.jjtGetNumChildren(); i++)
                                {
                                        Node child = node.jjtGetChild(i);
                                        if (!child.toString().contains("ASTSimpleOXPathStepPath") && hasActionOnMainPath(child)) return true;
                                }
                                return false;
                        }
           }

           public static Node getChildByName(Node parent, String name) throws OXPathException
           {
             for (int i = 0; i<parent.jjtGetNumChildren(); i++)
             {
               if (parent.jjtGetChild(i).toString().contains(name))
               {
                 return safeGetChild(parent,i);
               }
     }
     throw new OXPathException("Child not found!");
           }

                           public static int test(String tester)
                           {
                    System.out.println(tester);
    return 1;
   }

   public static boolean isDescendant(Node a, Node d)
   {
     if (a.equals(d)) return true;
     Node temp = d.jjtGetParent();
         while (!(temp==null))
         {
             if (a.equals(temp)) return true;
             temp = temp.jjtGetParent();
         }
         return false;
   }

//Apparently, we can't get rid of this - the AST needs a fixed root node for JavaCC
  final public Node Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathExpr();
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Letter() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UPPER_ALPHA:
      t = jj_consume_token(UPPER_ALPHA);
                        {if (true) return t.image;}
      break;
    case LOWER_ALPHA:
      t = jj_consume_token(LOWER_ALPHA);
                          {if (true) return t.image;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLName() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String sp;
 String hp;
 Token t1;
 String up;
 Token t2;
 String us;
    //adapted from w3c BNF grammar for BNF located @ http://www.w3.org/Addressing/URL/5_BNF.html#z18
      sp = SupportedProtocols();
    hp = HostPort();
                                             sb.append(sp); sb.append(hp);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH_URL:
      t1 = jj_consume_token(SLASH_URL);
      up = URLPath();
                                        sb.append(t1.image); sb.append(up);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION_URL:
      t2 = jj_consume_token(QUESTION_URL);
      us = URLSearch();
                                            sb.append(t2.image); sb.append(us);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String SupportedProtocols() throws ParseException {
 Token t;
    //current supported protocols of http and https
      t = jj_consume_token(PROTOCOL);
   {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String HostPort() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String h;
 Token t;
 int p;
    h = Host();
              sb.append(h);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      t = jj_consume_token(COLON);
      p = Port();
                                                         sb.append(t.image); sb.append(p);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Host() throws ParseException {
 String subtree;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER_ALPHA:
    case UPPER_ALPHA:
      subtree = HostName();
                         {if (true) return subtree;}
      break;
    case DIGIT:
      subtree = HostNumber();
                               {if (true) return subtree;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String HostName() throws ParseException {
 String subtree;
    subtree = URLIAlpha();
                         {if (true) return subtree;}
    throw new Error("Missing return statement in function");
  }

  final public String URLIAlpha() throws ParseException {
 StringBuilder st = new StringBuilder();
 String l;
 String u;
    l = Letter();
              st.append(l);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      u = URLXAlphas();
                                               st.append(u);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
   {if (true) return st.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlphas() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String u;
 String us;
    u = URLXAlpha();
                  sb.append(u);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      us = URLXAlphas();
                                                      sb.append(us);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
  {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLXAlpha() throws ParseException {
 String s;
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOWER_ALPHA:
    case UPPER_ALPHA:
      s = Letter();
                      {if (true) return s;}
      break;
    case DIGIT:
      t = jj_consume_token(DIGIT);
                       {if (true) return t.image;}
      break;
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case AT_URL:
    case PLUS_URL:
      s = URLSafe();
                       {if (true) return s;}
      break;
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
      s = URLExtra();
                        {if (true) return s;}
      break;
    case PERCENT_URL:
      s = URLEscape();
                         {if (true) return s;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLSafe() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOLLAR_URL:
      t = jj_consume_token(DOLLAR_URL);
                    {if (true) return t.image;}
      break;
    case MINUS_URL:
      t = jj_consume_token(MINUS_URL);
                   {if (true) return t.image;}
      break;
    case UNDERSCORE_URL:
      t = jj_consume_token(UNDERSCORE_URL);
                        {if (true) return t.image;}
      break;
    case AT_URL:
      t = jj_consume_token(AT_URL);
                {if (true) return t.image;}
      break;
    case PERIOD_URL:
      t = jj_consume_token(PERIOD_URL);
                    {if (true) return t.image;}
      break;
    case AMPERSAND_URL:
      t = jj_consume_token(AMPERSAND_URL);
                       {if (true) return t.image;}
      break;
    case PLUS_URL:
      t = jj_consume_token(PLUS_URL);
                  {if (true) return t.image;}
      break;
    case EQUALS_URL:
      t = jj_consume_token(EQUALS_URL);
                    {if (true) return t.image;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLExtra() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCLAIMATION_URL:
      t = jj_consume_token(EXCLAIMATION_URL);
                          {if (true) return t.image;}
      break;
    case STAR_URL:
      t = jj_consume_token(STAR_URL);
                  {if (true) return t.image;}
      break;
    case QUOTE_URL:
      t = jj_consume_token(QUOTE_URL);
                   {if (true) return t.image;}
      break;
    case APOSTROPHE_URL:
      t = jj_consume_token(APOSTROPHE_URL);
                        {if (true) return t.image;}
      break;
    case OPEN_PARAN_URL:
      t = jj_consume_token(OPEN_PARAN_URL);
                        {if (true) return t.image;}
      break;
    case CLOSE_PARAN_URL:
      t = jj_consume_token(CLOSE_PARAN_URL);
                         {if (true) return t.image;}
      break;
    case COMMA_URL:
      t = jj_consume_token(COMMA_URL);
                   {if (true) return t.image;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String URLEscape() throws ParseException {
 Token t;
    t = jj_consume_token(PERCENT_URL);
                     {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String HostNumber() throws ParseException {
 int s1;
 Token t1;
 int s2;
 Token t2;
 int s3;
 Token t3;
 int s4;
    s1 = Digits();
    t1 = jj_consume_token(PERIOD_URL);
    s2 = Digits();
    t2 = jj_consume_token(PERIOD_URL);
    s3 = Digits();
    t3 = jj_consume_token(PERIOD_URL);
    s4 = Digits();
   StringBuilder sb = new StringBuilder();
   sb.append(s1);
   sb.append(t1);
   sb.append(s2);
   sb.append(t2);
   sb.append(s3);
   sb.append(t3);
   sb.append(s4);
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public int Digits() throws ParseException {
 Token t;
 StringBuilder sb = new StringBuilder();
    label_1:
    while (true) {
      t = jj_consume_token(DIGIT);
                 sb.append(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_1;
      }
    }
   {if (true) return Integer.parseInt(sb.toString());}
    throw new Error("Missing return statement in function");
  }

  final public int Port() throws ParseException {
 int s;
    s = Digits();
              {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String URLPath() throws ParseException {
 StringBuilder sb = new StringBuilder();
 String s1;
 Token t;
 String s2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case APOSTROPHE_URL:
    case QUOTE_URL:
    case MINUS_URL:
    case UNDERSCORE_URL:
    case PERIOD_URL:
    case AMPERSAND_URL:
    case EQUALS_URL:
    case DOLLAR_URL:
    case PERCENT_URL:
    case AT_URL:
    case PLUS_URL:
    case EXCLAIMATION_URL:
    case STAR_URL:
    case OPEN_PARAN_URL:
    case CLOSE_PARAN_URL:
    case COMMA_URL:
    case LOWER_ALPHA:
    case UPPER_ALPHA:
    case DIGIT:
      s1 = URLSegment();
                    sb.append(s1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH_URL:
        t = jj_consume_token(SLASH_URL);
        s2 = URLPath();
                                                                    sb.append(t.image); sb.append(s2);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
   {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String URLSegment() throws ParseException {
 String s;
    s = URLXAlphas();
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String URLSearch() throws ParseException {
 String s;
    s = URLXAlphas();
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathPathSegment() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                           jjtn000.setHasComplexPath(true);
        break;
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        SimpleOXPathStepPath();
                          jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                      jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        break;
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
        SimpleOXPathStepTail();
                          jjtn000.setIsAbsolutePath(true); jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                                                      jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void RelativeOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                           jjtn000.setHasComplexPath(true);
        break;
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        SimpleOXPathStepPath();
                          jjtn000.setHasSimplePath(true);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                      jjtn000.setHasComplexPath(true);
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SimpleOXPathStepTail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      jj_consume_token(SLASH);
      SimpleOXPathStepPath();
      break;
    case DESCENDENT_OR_SELF_SHORT:
      SimpleOXPathDOSStepPath();

      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SimpleOXPathDOSStepPath() throws ParseException {
 /*@bgen(jjtree) SimpleOXPathStepPath */
  ASTSimpleOXPathStepPath jjtn000 = new ASTSimpleOXPathStepPath(JJTSIMPLEOXPATHSTEPPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      DescendantOrSelfShort();
      SimpleOXPathStepPath();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   jjtn000.setStep(new OXPathStep(ForwardAxis.DESCENDANTORSELF,XPathNameTest.WILDCARD));
   jjtn000.setHasList(true);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ComplexOXPathStepPath() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_KLEENE_STAR:
      OXPathKleeneStarPath();
      break;
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
    case BEGIN_USER_ACTION:
      OXPathActionPath();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DescendantOrSelfShort() throws ParseException {
    jj_consume_token(DESCENDENT_OR_SELF_SHORT);
  }

  final public void OXPathKleeneStarPath() throws ParseException {
 /*@bgen(jjtree) OXPathKleeneStarPath */
 ASTOXPathKleeneStarPath jjtn000 = new ASTOXPathKleeneStarPath(JJTOXPATHKLEENESTARPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);ArrayList<Integer> list;
    try {
      jj_consume_token(BEGIN_KLEENE_STAR);
      OXPathPathSegment();
      jj_consume_token(CLOSE_PARAN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        jj_consume_token(MULTIPLY);
                  jjtn000.setHasLowerBound(false);jjtn000.setHasUpperBound(false);
        break;
      case BEGIN_BOUNDED_KLEENE_STAR_PRED:
        jj_consume_token(BEGIN_BOUNDED_KLEENE_STAR_PRED);
        list = OXPathKleeneStarPredicate();
        jj_consume_token(CLOSE_CURLY);
       if (list.size()>1)
        {jjtn000.setHasLowerBound(true);
         jjtn000.setHasUpperBound(true);
         jjtn000.setLowerBound(list.get(0));
         jjtn000.setUpperBound(list.get(1));}
       else {jjtn000.setHasLowerBound(true); jjtn000.setHasUpperBound(false); jjtn000.setLowerBound(list.get(0));}
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
        RelativeOXPathLocationTail();
                                  jjtn000.setHasFollowingPath(true);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public ArrayList<Integer> OXPathKleeneStarPredicate() throws ParseException {
 ArrayList<Integer> result = new ArrayList<Integer>();
 int i1;
 int i2;
    i1 = OXPathKleeneStarPredicateArg();
                                     result.add(i1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      i2 = OXPathKleeneStarPredicateArg();
                                        result.add(i2);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public int OXPathKleeneStarPredicateArg() throws ParseException {
 Token t;
    t = jj_consume_token(DIGITS);
   {if (true) return Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathActionPath() throws ParseException {
 /*@bgen(jjtree) OXPathActionPath */
 ASTOXPathActionPath jjtn000 = new ASTOXPathActionPath(JJTOXPATHACTIONPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Action action;
    try {
      action = OXPathAction();
                               jjtn000.setAction(action);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
        RelativeOXPathLocationTail();
                                          jjtn000.setHasTail(true);
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void RelativeOXPathLocationTail() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
    case BEGIN_USER_ACTION:
    case BEGIN_KLEENE_STAR:
      ComplexOXPathStepPath();
      break;
    case SLASH:
      jj_consume_token(SLASH);
      RelativeOXPathLocationPath();
      break;
    case DESCENDENT_OR_SELF_SHORT:
      AbbreviatedAbsoluteOXPathLocationPath();
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SimpleOXPathStepPath() throws ParseException {
 /*@bgen(jjtree) SimpleOXPathStepPath */
 ASTSimpleOXPathStepPath jjtn000 = new ASTSimpleOXPathStepPath(JJTSIMPLEOXPATHSTEPPATH);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Step step;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case AT:
      case WILDCARD:
      case NCNAME:
        step = FullStep();
        break;
      case PERIOD:
      case PARENT_SHORT:
        step = AbbreviatedStep();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     jjtn000.setStep(step);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        OXPathPostStepList();
                         jjtn000.setHasList(true);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Step FullStep() throws ParseException {
 Axis axis = ForwardAxis.CHILD;//default unless overwritten
 NodeTest nodetest;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STYLE:
    case ATTRIBUTE:
    case CHILD:
    case DESCENDANTORSELF:
    case DESCENDANT:
    case FOLLOWINGSIBLING:
    case FOLLOWING:
    case NAMESPACE:
    case SELF:
    case ANCESTORORSELF:
    case ANCESTOR:
    case PARENT:
    case PRECEDINGSIBLING:
    case PRECEDING:
    case AT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
        axis = XPathForwardAxisName();
        break;
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
        axis = XPathBackwardAxisName();
        break;
      case AT:
        axis = XPathAbbreviatedAxisSpecifier();
        break;
      case STYLE:
        axis = OXPathAxisSpecifier();
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
    case TEXT:
    case PROCESSING_INSTRUCTION:
    case NODE:
    case WILDCARD:
    case NCNAME:
      nodetest = XPathNodeTest();
      break;
    case FIELD:
    case ANY_FIELD:
      nodetest = OXPathNodeTest();
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                               {if (true) return new OXPathStep(axis,nodetest);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathPostStepList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DESCENDENT_OR_SELF_SHORT:
    case SLASH:
      SimpleOXPathStepTail();
      break;
    case PERIOD_OP:
    case HASH:
      OXPathNodeTestOp();
      break;
    case OPEN_BRACKET:
      XPathPredicate();
      break;
    case OPEN_OPTIONAL:
      OXPathOptionalPredicate();
      break;
    case BEGIN_EXTRACT_MARK:
      OXPathExtractionMarker();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Axis OXPathAxisSpecifier() throws ParseException {
 Axis a;
    a = OXPathAxisName();
                      {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathForwardAxisName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATTRIBUTE:
      jj_consume_token(ATTRIBUTE);
                 {if (true) return ForwardAxis.ATTRIBUTE;}
      break;
    case CHILD:
      jj_consume_token(CHILD);
             {if (true) return ForwardAxis.CHILD;}
      break;
    case DESCENDANTORSELF:
      jj_consume_token(DESCENDANTORSELF);
                        {if (true) return ForwardAxis.DESCENDANTORSELF;}
      break;
    case DESCENDANT:
      jj_consume_token(DESCENDANT);
                  {if (true) return ForwardAxis.DESCENDANT;}
      break;
    case FOLLOWINGSIBLING:
      jj_consume_token(FOLLOWINGSIBLING);
                        {if (true) return ForwardAxis.FOLLOWINGSIBLING;}
      break;
    case FOLLOWING:
      jj_consume_token(FOLLOWING);
                 {if (true) return ForwardAxis.FOLLOWING;}
      break;
    case NAMESPACE:
      jj_consume_token(NAMESPACE);
                 {if (true) return ForwardAxis.NAMESPACE;}
      break;
    case SELF:
      jj_consume_token(SELF);
            {if (true) return ForwardAxis.SELF;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathBackwardAxisName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANCESTORORSELF:
      jj_consume_token(ANCESTORORSELF);
                      {if (true) return BackwardAxis.ANCESTORORSELF;}
      break;
    case ANCESTOR:
      jj_consume_token(ANCESTOR);
                {if (true) return BackwardAxis.ANCESTOR;}
      break;
    case PARENT:
      jj_consume_token(PARENT);
              {if (true) return BackwardAxis.PARENT;}
      break;
    case PRECEDINGSIBLING:
      jj_consume_token(PRECEDINGSIBLING);
                        {if (true) return BackwardAxis.PRECEDINGSIBLING;}
      break;
    case PRECEDING:
      jj_consume_token(PRECEDING);
                 {if (true) return BackwardAxis.PRECEDING;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Axis OXPathAxisName() throws ParseException {
    jj_consume_token(STYLE);
             {if (true) return OXPathAxis.STYLE;}
    throw new Error("Missing return statement in function");
  }

  final public Axis XPathAbbreviatedAxisSpecifier() throws ParseException {
    jj_consume_token(AT);
          {if (true) return AbbreviatedAxis.AT;}
    throw new Error("Missing return statement in function");
  }

  final public NodeTest XPathNodeTest() throws ParseException {
 NodeTest nt;
 String parameter = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WILDCARD:
    case NCNAME:
      nt = XPathNameTest();
                      {if (true) return nt;}
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(CLOSE_PARAN);
                               {if (true) return XPathNodeTest.COMMENT;}
      break;
    case TEXT:
      jj_consume_token(TEXT);
      jj_consume_token(CLOSE_PARAN);
                            {if (true) return XPathNodeTest.TEXT;}
      break;
    case PROCESSING_INSTRUCTION:
      jj_consume_token(PROCESSING_INSTRUCTION);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        parameter = XPathLiteral(false);
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
                                                                              {if (true) return (parameter.equals(""))?XPathNodeTest.PROCESSINGINSTRUCTION:new ParameterizedProcessingInstruction(parameter);}
      break;
    case NODE:
      jj_consume_token(NODE);
      jj_consume_token(CLOSE_PARAN);
                            {if (true) return XPathNodeTest.NODE;}
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public NodeTest OXPathNodeTest() throws ParseException {
 NodeTest nodetest;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FIELD:
      jj_consume_token(FIELD);
               nodetest=OXPathNodeTest.FIELD;
      break;
    case ANY_FIELD:
      jj_consume_token(ANY_FIELD);
                                                                nodetest=OXPathNodeTest.ANYFIELD;
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSE_PARAN);
   {if (true) return nodetest;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathNodeTestOp() throws ParseException {
 /*@bgen(jjtree) OXPathNodeTestOp */
 ASTOXPathNodeTestOp jjtn000 = new ASTOXPathNodeTestOp(JJTOXPATHNODETESTOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Selector select;
 Token value;
    try {
      select = OXPathNodeTestOper();
      value = jj_consume_token(NCNAME);
                                                jjtn000.setSelectorPredicate(new SelectorPredicate(select,value.image));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        OXPathPostStepList();
                         jjtn000.setHasList(true);
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Selector OXPathNodeTestOper() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD_OP:
      jj_consume_token(PERIOD_OP);
                 {if (true) return Selector.CLASS;}
      break;
    case HASH:
      jj_consume_token(HASH);
            {if (true) return Selector.ID;}
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public XPathNameTest XPathNameTest() throws ParseException {
 Token tp;
 Token ts;
 NodeTest nt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WILDCARD:
      ts = jj_consume_token(WILDCARD);
                   {if (true) return new XPathNameTest(ts.image,true);}
      break;
    case NCNAME:
      tp = jj_consume_token(NCNAME);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WILDCARD:
          ts = jj_consume_token(WILDCARD);
                     {if (true) return new XPathNameTest(tp.image,ts.image,true);}
          break;
        case NCNAME:
          ts = jj_consume_token(NCNAME);
                   {if (true) return new XPathNameTest(tp.image,ts.image,false);}
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
   {if (true) return new XPathNameTest(tp.image,false);}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String XPathLiteral(boolean node) throws ParseException {
 /*@bgen(jjtree) #XPathLiteral( node) */
 ASTXPathLiteral jjtn000 = new ASTXPathLiteral(JJTXPATHLITERAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE_QUOTE_STRING_PATH:
        t = jj_consume_token(DOUBLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000,  node);
                                       jjtc000 = false;
                                      jjtn000.setValue(t.image); {if (true) return jjtn000.getValue();}
        break;
      case SINGLE_QUOTE_STRING_PATH:
        t = jj_consume_token(SINGLE_QUOTE_STRING_PATH);
                                       jjtree.closeNodeScope(jjtn000,  node);
                                       jjtc000 = false;
                                      jjtn000.setValue(t.image); {if (true) return jjtn000.getValue();}
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  node);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathPredicate() throws ParseException {
 /*@bgen(jjtree) XPathPredicate */
  ASTXPathPredicate jjtn000 = new ASTXPathPredicate(JJTXPATHPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OPEN_BRACKET);
      XPathExpr();
      jj_consume_token(CLOSE_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        OXPathPostStepList();
                         jjtn000.setHasList(true);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void OXPathOptionalPredicate() throws ParseException {
 /*@bgen(jjtree) XPathPredicate */
  ASTXPathPredicate jjtn000 = new ASTXPathPredicate(JJTXPATHPREDICATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OPEN_OPTIONAL);
                     jjtn000.setIsOptional(true);
      XPathExpr();
      jj_consume_token(CLOSE_BRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        OXPathPostStepList();
                         jjtn000.setHasList(true);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Action OXPathAction() throws ParseException {
 Action a;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOC_BEGIN:
    case BEGIN_URL_IN_PATH:
      a = OXPathURLAction();
      break;
    case BEGIN_USER_ACTION:
      a = OXPathUserAction();
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathURLAction() throws ParseException {
 Action a;
 String s;
 long l;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_URL_IN_PATH:
      jj_consume_token(BEGIN_URL_IN_PATH);
      s = URLName();
      jj_consume_token(END_URL_IN_PATH);
   a= new URLAction(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
        l = OXPathActionPred();
                         a.setWait(l);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      jj_consume_token(SLASH);
      jj_consume_token(CLOSE_CURLY);
      break;
    case DOC_BEGIN:
      jj_consume_token(DOC_BEGIN);
      s = XPathLiteral(false);
   a= new URLAction(s);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        l = OXPathActionPred();
                                   a.setWait(l);
        break;
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
   {if (true) return a;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathUserAction() throws ParseException {
 Action a;
 long l;
    jj_consume_token(BEGIN_USER_ACTION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGITS:
      a = GroundedOXPathActionPosition();
      break;
    case DOUBLE_QUOTE_STRING_PATH:
    case SINGLE_QUOTE_STRING_PATH:
      a = GroundedOXPathActionExplicit();
      break;
    case FOCUS:
    case CLICK:
    case DBLCLICK:
    case MOUSEDOWN:
    case MOUSEENTER:
    case MOUSEMOVE:
    case MOUSEOVER:
    case MOUSEOUT:
    case MOUSEUP:
    case WHEEL:
    case SUBMIT:
    case CHECK:
    case UNCHECK:
      a = OXPathActionKeyword();
      break;
    case VARIABLE:
      a = OXPathActionVariable();
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      l = OXPathActionPred();
                          a.setWait(l);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLASH:
      OXPathAbsoluteActionSignal();
                                  a.setIsAbsoluteAction(true);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_CURLY);
   {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

  final public long OXPathActionPred() throws ParseException {
 long wait;
    jj_consume_token(OPEN_BRACKET);
    wait = OXPathActionWaitPred();
    jj_consume_token(CLOSE_BRACKET);
                                                                  {if (true) return wait;}
    throw new Error("Missing return statement in function");
  }

  final public long OXPathActionWaitPred() throws ParseException {
 Token wait;
    jj_consume_token(WAIT);
    wait = jj_consume_token(DIGITS);
   {if (true) return Long.parseLong(wait.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathAbsoluteActionSignal() throws ParseException {
    jj_consume_token(SLASH);
  }

  final public Action GroundedOXPathActionPosition() throws ParseException {
 Token t;
    t = jj_consume_token(DIGITS);
                {if (true) return new PositionAction(Integer.parseInt(t.image));}
    throw new Error("Missing return statement in function");
  }

  final public Action GroundedOXPathActionExplicit() throws ParseException {
 String s;
    s = XPathLiteral(false);
                         {if (true) return new ExplicitAction(s);}
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathActionKeyword() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOCUS:
      t = jj_consume_token(FOCUS);
               {if (true) return new KeywordAction(ActionKeywords.FOCUS);}
      break;
    case CLICK:
      t = jj_consume_token(CLICK);
               {if (true) return new KeywordAction(ActionKeywords.CLICK);}
      break;
    case DBLCLICK:
      t = jj_consume_token(DBLCLICK);
                  {if (true) return new KeywordAction(ActionKeywords.DBLCLICK);}
      break;
    case MOUSEDOWN:
      t = jj_consume_token(MOUSEDOWN);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEDOWN);}
      break;
    case MOUSEENTER:
      t = jj_consume_token(MOUSEENTER);
                    {if (true) return new KeywordAction(ActionKeywords.MOUSEENTER);}
      break;
    case MOUSEMOVE:
      t = jj_consume_token(MOUSEMOVE);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEMOVE);}
      break;
    case MOUSEOVER:
      t = jj_consume_token(MOUSEOVER);
                   {if (true) return new KeywordAction(ActionKeywords.MOUSEOVER);}
      break;
    case MOUSEOUT:
      t = jj_consume_token(MOUSEOUT);
                  {if (true) return new KeywordAction(ActionKeywords.MOUSEOUT);}
      break;
    case MOUSEUP:
      t = jj_consume_token(MOUSEUP);
                 {if (true) return new KeywordAction(ActionKeywords.MOUSEUP);}
      break;
    case WHEEL:
      t = jj_consume_token(WHEEL);
               {if (true) return new KeywordAction(ActionKeywords.WHEEL);}
      break;
    case SUBMIT:
      t = jj_consume_token(SUBMIT);
                {if (true) return new KeywordAction(ActionKeywords.SUBMIT);}
      break;
    case CHECK:
      t = jj_consume_token(CHECK);
               {if (true) return new KeywordAction(ActionKeywords.CHECK);}
      break;
    case UNCHECK:
      t = jj_consume_token(UNCHECK);
                 {if (true) return new KeywordAction(ActionKeywords.UNCHECK);}
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Action OXPathActionVariable() throws ParseException {
 Token t;
    t = jj_consume_token(VARIABLE);
                  {if (true) return new VariableAction(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathExtractionMarker() throws ParseException {
 /*@bgen(jjtree) OXPathExtractionMarker */
 ASTOXPathExtractionMarker jjtn000 = new ASTOXPathExtractionMarker(JJTOXPATHEXTRACTIONMARKER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);String s;
 boolean isAttribute = false;
    try {
      jj_consume_token(BEGIN_EXTRACT_MARK);
      s = OXPathExtractionName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        jj_consume_token(EQUALS);
        OXPathExtractionValue();
                                        isAttribute = true;
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case END_EXTRACT_MARK:
        jj_consume_token(END_EXTRACT_MARK);
        break;
      case GREATER:
        jj_consume_token(GREATER);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtn000.setExtractionMarker(new OXPathExtractionMarker(s,isAttribute));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_OPTIONAL:
      case OPEN_BRACKET:
      case DESCENDENT_OR_SELF_SHORT:
      case SLASH:
      case BEGIN_EXTRACT_MARK:
      case PERIOD_OP:
      case HASH:
        OXPathPostStepList();
                          jjtn000.setHasList(true);
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public String OXPathExtractionName() throws ParseException {
 Token t;
    t = jj_consume_token(NCNAME);
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public void OXPathExtractionValue() throws ParseException {
    XPathPrimaryExpr();
  }

  final public void XPathExpr() throws ParseException {
    XPathOrExpr();
  }

  final public void XPathOrExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathAndExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
                           jjtn000.setBinaryOperator(HigherLevelOp.OR);
        XPathOrExpr();
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void XPathAndExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathEqualityExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
                                 jjtn000.setBinaryOperator(HigherLevelOp.AND);
        XPathAndExpr();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void XPathEqualityExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);EqualityExprOp op;
    try {
      XPathRelationalExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOTEQUAL:
      case EQUALS:
      case WORD_TEST:
      case CONTAINS:
        op = XPathEqualityExprOp();
                               jjtn000.setBinaryOperator(op);
        XPathEqualityExpr();
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public EqualityExprOp XPathEqualityExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      jj_consume_token(EQUALS);
              {if (true) return EqualityExprOp.EQUALS;}
      break;
    case NOTEQUAL:
      jj_consume_token(NOTEQUAL);
                {if (true) return EqualityExprOp.NOTEQUAL;}
      break;
    case WORD_TEST:
      jj_consume_token(WORD_TEST);
                  {if (true) return EqualityExprOp.WORDTEST;}
      break;
    case CONTAINS:
      jj_consume_token(CONTAINS);
                 {if (true) return EqualityExprOp.CONTAINS;}
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathRelationalExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);RelationalExprOp op;
    try {
      XPathAdditiveExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESSTE:
      case LESS:
      case GREATERTE:
      case GREATER:
        op = XPathRelationalExprOp();
                                jjtn000.setBinaryOperator(op);
        XPathRelationalExpr();
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public RelationalExprOp XPathRelationalExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GREATER:
      jj_consume_token(GREATER);
               {if (true) return RelationalExprOp.GREATER;}
      break;
    case LESS:
      jj_consume_token(LESS);
            {if (true) return RelationalExprOp.LESS;}
      break;
    case GREATERTE:
      jj_consume_token(GREATERTE);
                 {if (true) return RelationalExprOp.GREATERTE;}
      break;
    case LESSTE:
      jj_consume_token(LESSTE);
              {if (true) return RelationalExprOp.LESSTE;}
      break;
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathAdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);AdditiveExprOp op;
    try {
      XPathMultiplicativeExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        op = AdditiveExprOp();
                         jjtn000.setBinaryOperator(op);
        XPathAdditiveExpr();
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public AdditiveExprOp AdditiveExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
            {if (true) return AdditiveExprOp.PLUS;}
      break;
    case MINUS:
      jj_consume_token(MINUS);
             {if (true) return AdditiveExprOp.MINUS;}
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathMultiplicativeExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
 ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);MultiplicativeExprOp op;
    try {
      XPathUnaryExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MOD:
      case DIV:
      case MULTIPLY:
        op = MultiplicativeExprOp();
                               jjtn000.setBinaryOperator(op);
        XPathMultiplicativeExpr();
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public MultiplicativeExprOp MultiplicativeExprOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
                {if (true) return MultiplicativeExprOp.MULTIPLY;}
      break;
    case DIV:
      jj_consume_token(DIV);
           {if (true) return MultiplicativeExprOp.DIV;}
      break;
    case MOD:
      jj_consume_token(MOD);
           {if (true) return MultiplicativeExprOp.MOD;}
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathUnaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathUnaryExpr( hasOp) */
 ASTXPathUnaryExpr jjtn000 = new ASTXPathUnaryExpr(JJTXPATHUNARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean hasOp = false;
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEGATIVE:
          ;
          break;
        default:
          jj_la1[65] = jj_gen;
          break label_2;
        }
        XPathUnaryExprOp();
                        jjtn000.incrementOperatorNumber(); hasOp=true;
      }
      XPathUnionExpr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  hasOp);
    }
    }
  }

  final public void XPathUnaryExprOp() throws ParseException {
    jj_consume_token(NEGATIVE);
  }

  final public void XPathPrimaryExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPrimaryExpr( parans) */
 ASTXPathPrimaryExpr jjtn000 = new ASTXPathPrimaryExpr(JJTXPATHPRIMARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean parans = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
        jj_consume_token(OPEN_PARAN);
                  parans=true;
        XPathExpr();
        jj_consume_token(CLOSE_PARAN);
        break;
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathLiteral(true);
        break;
      case NUMBER:
      case DIGITS:
        XPathNumber();
        break;
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
        XPathFunctionCall();
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  parans);
    }
    }
  }

  final public double XPathNumber() throws ParseException {
 /*@bgen(jjtree) XPathNumber */
 ASTXPathNumber jjtn000 = new ASTXPathNumber(JJTXPATHNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        t = jj_consume_token(NUMBER);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setValue(Double.parseDouble(t.image)); {if (true) return jjtn000.getValue();}
        break;
      case DIGITS:
        t = jj_consume_token(DIGITS);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setValue(Double.parseDouble(t.image)); {if (true) return jjtn000.getValue();}
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathFunctionCall() throws ParseException {
 /*@bgen(jjtree) XPathFunctionCall */
 ASTXPathFunctionCall jjtn000 = new ASTXPathFunctionCall(JJTXPATHFUNCTIONCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);XPathFunction function;
    try {
      function = XPathFunctionCallName();
                                    jjtn000.setFunction(function);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case OPEN_PARAN:
      case BEGIN_URL_IN_PATH:
      case NUMBER:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
      case NEGATIVE:
      case WILDCARD:
      case NCNAME:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathArgument();
                     jjtn000.addParameter();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[68] = jj_gen;
            break label_3;
          }
          jj_consume_token(COMMA);
          XPathArgument();
                                                                           jjtn000.addParameter();
        }
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_PARAN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public XPathFunction XPathFunctionCallName() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSITION:
      jj_consume_token(POSITION);
                {if (true) return XPathFunctions.POSITION;}
      break;
    case LAST:
      jj_consume_token(LAST);
            {if (true) return XPathFunctions.LAST;}
      break;
    case COUNT:
      jj_consume_token(COUNT);
             {if (true) return XPathFunctions.COUNT;}
      break;
    case ID:
      jj_consume_token(ID);
          {if (true) return XPathFunctions.ID;}
      break;
    case NAMESPACEURI:
      jj_consume_token(NAMESPACEURI);
                    {if (true) return XPathFunctions.NAMESPACEURI;}
      break;
    case LOCALNAME:
      jj_consume_token(LOCALNAME);
                 {if (true) return XPathFunctions.LOCALNAME;}
      break;
    case NAME:
      jj_consume_token(NAME);
            {if (true) return XPathFunctions.NAME;}
      break;
    case STRING:
      jj_consume_token(STRING);
              {if (true) return XPathFunctions.STRING;}
      break;
    case CONCAT:
      jj_consume_token(CONCAT);
              {if (true) return XPathFunctions.CONCAT;}
      break;
    case STARTSWITH:
      jj_consume_token(STARTSWITH);
                  {if (true) return XPathFunctions.STARTSWITH;}
      break;
    case CONTAINSFUNC:
      jj_consume_token(CONTAINSFUNC);
                    {if (true) return XPathFunctions.CONTAINS;}
      break;
    case SUBSTRINGBEFORE:
      jj_consume_token(SUBSTRINGBEFORE);
                       {if (true) return XPathFunctions.SUBSTRINGBEFORE;}
      break;
    case SUBSTRINGAFTER:
      jj_consume_token(SUBSTRINGAFTER);
                      {if (true) return XPathFunctions.SUBSTRINGAFTER;}
      break;
    case SUBSTRING:
      jj_consume_token(SUBSTRING);
                 {if (true) return XPathFunctions.SUBSTRING;}
      break;
    case SUBSTRINGLENGTH:
      jj_consume_token(SUBSTRINGLENGTH);
                        {if (true) return XPathFunctions.SUBSTRINGLENGTH;}
      break;
    case NORMALIZESPACE:
      jj_consume_token(NORMALIZESPACE);
                      {if (true) return XPathFunctions.NORMALIZESPACE;}
      break;
    case TRANSLATE:
      jj_consume_token(TRANSLATE);
                 {if (true) return XPathFunctions.TRANSLATE;}
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
               {if (true) return XPathFunctions.BOOLEAN;}
      break;
    case NOT:
      jj_consume_token(NOT);
           {if (true) return XPathFunctions.NOT;}
      break;
    case TRUE:
      jj_consume_token(TRUE);
            {if (true) return XPathFunctions.TRUE;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
             {if (true) return XPathFunctions.FALSE;}
      break;
    case LANG:
      jj_consume_token(LANG);
            {if (true) return XPathFunctions.LANG;}
      break;
    case NUMBERFUNC:
      jj_consume_token(NUMBERFUNC);
                  {if (true) return XPathFunctions.NUMBER;}
      break;
    case SUM:
      jj_consume_token(SUM);
           {if (true) return XPathFunctions.SUM;}
      break;
    case FLOOR:
      jj_consume_token(FLOOR);
             {if (true) return XPathFunctions.FLOOR;}
      break;
    case CEILING:
      jj_consume_token(CEILING);
               {if (true) return XPathFunctions.CEILING;}
      break;
    case ROUND:
      jj_consume_token(ROUND);
             {if (true) return XPathFunctions.ROUND;}
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPathArgument() throws ParseException {
    XPathExpr();
  }

  final public void XPathUnionExpr() throws ParseException {
 /*@bgen(jjtree) #BinaryOpExpr(> 1) */
  ASTBinaryOpExpr jjtn000 = new ASTBinaryOpExpr(JJTBINARYOPEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPathPathExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNION:
        jj_consume_token(UNION);
   jjtn000.setBinaryOperator(HigherLevelOp.UNION);
        XPathUnionExpr();
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

// * The WARNING generated by the ambiguity in this rule is purposeful; the default (first rule condition satisfied) is what we always want.
// * This is because we restrict Kleene-Stars that begin with path expressions to start with / or // (in this way, no relative expressions can start with Kleene stars).
// * This restriction is necessary so as to save arbitrary lookahead as an entire unbounded relative OXPath expression must be parsed to determine if an operator and new expression occur afterwards.
// * This restriction results in no loss of expressivity.  Simply use ./(Kleene-star-expr)* in order to preserve context.
// * We treat the additional OXPath "step" feature - user actions - similiarly.
// * The LOOKAHEAD(1) is to simply suppress the warning; lets JavaCC know that the ambiguity was a deliberate choice.
  final public void XPathPathExpr() throws ParseException {
 /*@bgen(jjtree) #XPathPathExpr(> 1) */
  ASTXPathPathExpr jjtn000 = new ASTXPathPathExpr(JJTXPATHPATHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PARAN:
      case NUMBER:
      case POSITION:
      case LAST:
      case COUNT:
      case ID:
      case NAMESPACEURI:
      case LOCALNAME:
      case NAME:
      case STRING:
      case CONCAT:
      case STARTSWITH:
      case CONTAINSFUNC:
      case SUBSTRINGBEFORE:
      case SUBSTRINGAFTER:
      case SUBSTRING:
      case SUBSTRINGLENGTH:
      case NORMALIZESPACE:
      case TRANSLATE:
      case BOOLEAN:
      case NOT:
      case TRUE:
      case FALSE:
      case LANG:
      case NUMBERFUNC:
      case SUM:
      case FLOOR:
      case CEILING:
      case ROUND:
      case DIGITS:
      case DOUBLE_QUOTE_STRING_PATH:
      case SINGLE_QUOTE_STRING_PATH:
        XPathPrimaryExpr();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_OPTIONAL:
        case OPEN_BRACKET:
        case DESCENDENT_OR_SELF_SHORT:
        case SLASH:
        case BEGIN_EXTRACT_MARK:
        case PERIOD_OP:
        case HASH:
          OXPathPostStepList();
                                              jjtn000.setHasSimpleList(true);
          break;
        default:
          jj_la1[72] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOC_BEGIN:
        case BEGIN_URL_IN_PATH:
        case BEGIN_USER_ACTION:
        case BEGIN_KLEENE_STAR:
          ComplexOXPathStepPath();
                                                                                                            jjtn000.setHasComplexList(true);
          break;
        default:
          jj_la1[73] = jj_gen;
          ;
        }
        break;
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case DESCENDENT_OR_SELF_SHORT:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
      case SLASH:
      case STYLE:
      case ATTRIBUTE:
      case CHILD:
      case DESCENDANTORSELF:
      case DESCENDANT:
      case FOLLOWINGSIBLING:
      case FOLLOWING:
      case NAMESPACE:
      case SELF:
      case ANCESTORORSELF:
      case ANCESTOR:
      case PARENT:
      case PRECEDINGSIBLING:
      case PRECEDING:
      case COMMENT:
      case TEXT:
      case PROCESSING_INSTRUCTION:
      case NODE:
      case FIELD:
      case ANY_FIELD:
      case PERIOD:
      case PARENT_SHORT:
      case AT:
      case WILDCARD:
      case NCNAME:
        OXPathPathSegment();
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
    }
  }

//here, we restrict the Complex steps similiarly so that //ComplexOXPathStepPath isn't possible.
//as with the restriction of the relative OXPath location path beginning with a complex step, this restriction
//makes a cleaner semantics, a much more efficient parser (we remain at LL(1)), and no loss of expressivity (as
//this can be simulated with //*/ComplexOXPathStepPath
  final public void AbbreviatedAbsoluteOXPathLocationPath() throws ParseException {
 /*@bgen(jjtree) RelativeOXPathLocationPath */
  ASTRelativeOXPathLocationPath jjtn000 = new ASTRelativeOXPathLocationPath(JJTRELATIVEOXPATHLOCATIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SimpleOXPathDOSStepPath();
                             jjtn000.setHasSimplePath(true);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC_BEGIN:
      case BEGIN_URL_IN_PATH:
      case BEGIN_USER_ACTION:
      case BEGIN_KLEENE_STAR:
        ComplexOXPathStepPath();
                            jjtn000.setHasComplexPath(true);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public Step AbbreviatedStep() throws ParseException {
 Step s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD:
      s = AbbreviatedSelfStep();
      break;
    case PARENT_SHORT:
      s = AbbreviatedParentStep();
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
 {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Step AbbreviatedSelfStep() throws ParseException {
    jj_consume_token(PERIOD);
              {if (true) return AbbreviatedStep.SELF;}
    throw new Error("Missing return statement in function");
  }

  final public Step AbbreviatedParentStep() throws ParseException {
    jj_consume_token(PARENT_SHORT);
                    {if (true) return AbbreviatedStep.PARENT;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public OXPathParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[77];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x400000,0x800000,0x0,0x0,0xff000006,0xff000006,0xff000006,0xbf000000,0x6,0x0,0x400000,0xff000006,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff80,0x0,0x0,0xfff80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xc0,0x0,0x0,0x0,0x1c0,0x1ff,0x1ff,0x1ff,0x1,0x3e,0x100,0x0,0x1ff,0x1820800,0x1820800,0xf5c20800,0x1820800,0xf1820800,0x4400000,0x1820800,0x2000000,0x5c20800,0x100000,0x5c20800,0x5c20800,0xf0000000,0xc40c000,0xf0000000,0xf0000000,0x0,0xc40c000,0xe0000000,0x0,0x0,0x0,0x0,0xc40c000,0x0,0x0,0x0,0x0,0x0,0xc40c000,0xc40c000,0x820800,0x8000,0x100000,0x20800,0x0,0x8000,0x4000000,0x0,0x0,0x0,0xc40c000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201000,0x200000,0x100000,0xf5e21800,0x0,0x0,0xc40c000,0x1820800,0xf5e21800,0x1820800,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffbff,0x0,0xffbff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffbff,0x0,0x803ff,0x803ff,0x1f800,0x0,0x1f,0x3e0,0x0,0x7800,0x18000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfff00000,0x0,0x0,0xfffffbff,0xfff00000,0x0,0x0,0x0,0xfffffbff,0x0,0x60000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x80000000,0x20010000,0x0,0x80000,0x40000,0xc0000000,0xc0000000,0x3c000000,0x3c000000,0x3000000,0x3000000,0x700000,0x700000,0x20000,0x7fff,0x0,0x0,0x27fff,0x7fff,0x800000,0x0,0x0,0x7fff,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x0,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x3,0x0,0x0,0x180,0x3,0x0,0x0,0x12000,0x180,0x0,0x3,0x3,0x180,0x400,0x180,0x12000,0x3,0x3,0x0,0x0,0x0,0x0,0x12800,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xc,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x12800,0x800,0x0,0x12980,0x0,0x0,0x3,0x0,0x12980,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public OXPathParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public OXPathParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OXPathParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public OXPathParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OXPathParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public OXPathParser(OXPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(OXPathParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 77; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[146];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 77; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 146; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
